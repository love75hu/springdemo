并发执行的进程数量不受限制于CPU数量，操作系统会为每个进程分配CPU时间片。给人并行处理的感觉。
进程是程序的一次动态执行过程，每个进程都有自己独立的内存空间。一个应用程序可以同时启动多个进程(比如浏览器可以开多个窗口，每个窗口就是一个进程)

线程是进程的一个执行流程，一个进程可以由多个线程组成，也就是一个进程可以同时运行多个不同的线程，每个线程完成不同的任务。
线程的并发运行：就是一个进程内若干个线程同时运行。(比如：word的拼写检查功能和首字母自动大写功能是word进程中的线程)

多进程和多线程有什么区别？
本质区别是每个进程都拥有自己的一整套变量，现成则共享数据。共享数据有风险，但是共享变量使线程之间的通信比进行之间的通信更高效。
同时线程比进程更加轻量级，创建、撤销的开销要小得多。

线程状态：
New 新建
Runnable 可运行
Blocked 阻塞（）
Waiting 等待
Timed_waiting 计时等待
Terminated 终止
需要确定一个线程的状态，只需要调用getState方法。

新建线程：
当用new操作符新建一个线程的时候，如： Thred(r) ，这个线程还没有开始运行，这意味它的状态是新建（new）,当一个线程处于new 状态时候，
程序还没有开始运行线程中的代码，现成可运行之前还有一些基础工作要做。

可运行线程：
一旦调用start方法，线程就处于runnable状态，一个可运行的线程可能正在运行，也可能没有运行。要由操作系统为线程提供具体的运行时间。
（java 没有把正在运行作为一个单独的状态。）
一个一个线程开始运行，它不一定一直保持运行，事实上，运行中的线程有时候需要暂停，让其他线程有机会运行。线程调度的细节依赖操作系统
提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统就会剥夺该线程的运行权，并给另外一个线程来运行。
当下一个线程运行时，操作系统会考虑线程的优先级（priority）。
现代桌面和服务器系统都是抢占式调度，像手机这样的小型设备可能是协作式调度。一个线程只有在调用yield()或者阻塞或等待时候才会失去控制权。
在多个处理器的机器上，每个处理器可运行一个线程，而且可以有多个线程并行。当然如果线程数量多于处理器数目，调度器还需要分配时间片。

static void yield()
使当前正在执行的线程向另一个线程交出运作权。注意，这是一个静态方法。

阻塞和等待线程：
当线程处于阻塞（Blocked ）或等待线程（Waiting）时候，它暂时是不活动的，它不执行任何代码，并且消耗最少的资源。要由线程调度器重新激活这个线程。
具体细节取决于它是怎样到达非活动状态的。
1、当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的lock）,而这个锁被其他线程占有。该线程就会被阻塞。
   当所有其他线程释放这个锁，并且线程调度器运行该线程持有这个锁，它将变成非阻塞状态。

2、当线程等待另一个线程通知调度器出现某个条件时，这个线程会进入等待状态，调用object.wait方法或Thread.join方法，或者是等待
java.util.concurrent 库中的Lock 或Condition时，就会出现这个情况，实际上，阻塞状态和等待状态没有太大区别。

3、有几个方法有超时参数，调用这些方法会让线程进入计时等待(time waiting)状态，这一状态将一直保持到超时期满或者接收到适当的通知。
带有超时参数的方法 Thread.sleep和计时版Object.wait、Thread.join、Lock.tryLock以及Condition.await。


终止线程：
现成会由以下两个原因之一而被终止：
1、由于run方法正常退出，现成自然终止；
2、因为一个没有捕获的异常终止了run方法，使线程意外终止；

java.lang.Thread
void join
等待指定的线程终止

Thread.State getState()
得到这个线程的状态

void stop()
停止该线程，已经废弃

void suspend()
暂停这个线程的执行，这个方法已经废弃

void resume()
恢复线程，，这个方法已经废弃








